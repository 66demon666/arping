unit PcapTypes;

interface

uses WinSock;

const
  PCAP_SRC_IF_STRING = 'rpcap://';
  PCAP_ERRBUF_SIZE = 256;
  PCAP_OPENFLAG_PROMISCUOUS = 1;

type

  Pbpf_insn = ^Tbpf_insn;

  Tbpf_insn = record
    code: Word; // Код операции
    jt: Byte; // Индекс перехода, если true
    jf: Byte; // Индекс перехода, если false
    k: Cardinal; // Дополнительные данные
  end;

  Pbpf_program = ^Tbpf_program;

  Tbpf_program = record
    bf_len: Cardinal; // Количество инструкций
    bf_insns: Pbpf_insn; // Указатель на массив инструкций
  end;

  TTimeval = record
    tv_sec: Longint; // Секунды
    tv_usec: Longint; // Микросекунды
  end;

  PTimeVal = ^timeval; // Указатель на timeval

  TPcap_pkthdr = packed record
    ts: TTimeval;
    caplen: Cardinal;
    len: Cardinal;
  end;

  PPcap_pkthdr = ^TPcap_pkthdr;

  tpcap_handler = procedure(param: PByte; pkthdr: PPcap_pkthdr;
    packet_data: PByte);

  TPcapErrbuf = array [0 .. PCAP_ERRBUF_SIZE - 1] of AnsiChar;
  PPcap_rmtauth = ^TPcap_rmtauth;

  TPcap_rmtauth = packed record
    pcap_type: integer;
    username: PAnsiChar;
    password: PAnsiChar;
  end;

  PPcap_addr = ^TPcap_addr;

  TPcap_addr = packed record
    next: PPcap_addr;
    addr: Psockaddr;
    netmask: Psockaddr;
    broadaddr: Psockaddr;
    dstaddr: Psockaddr;
  end;

  PPPcap_if = ^PPcap_if;
  PPcap_if = ^TPcap_if;

  TPcap_if = packed record
    next: PPcap_if;
    name: PAnsiChar;
    description: PAnsiChar;
    addresses: PPcap_addr;
    flags: Cardinal;
  end;

  PPcap_t = ^Tpcap_t;

  Tpcap_t = packed record
  end;

implementation

end.
